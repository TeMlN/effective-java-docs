### 생성자 대신 정적 팩토리 메서드를 사용해라.

#### 정적 팩토리 메소드의 사용법
클래스 안에 public 접근 제어자를 가지는 static inner method로 객체를 생성한다.
`ex)LocalDate.of`

<br>

#### 정적 팩토리 메소드의 장점
* ##### 생성자와는 달리 메서드의 이름을 지정해줄 수 있다.

생성자는 signature별로 하나의 생성자만 생성할 수 있다. 하지만 이 제약을 피하는 방법이 존재하는데 그것은 바로 생성자 signature의 parameter 순서를 바꾸는 행위이다. 바로 이렇게 말이다.
```java
constructor(Long id, String memberName)
constructor(String memberName, String id)
```
이렇게 같은 parameter를 받지만 signature는 다른 생성자 두개가 생성된다. 하지만 문제는 여기서다
이 생성자를 작성한 개발자도 기억을 하기 어려울 터인데 이 API를 사용하는 사용자는 절대 이 생성자의 존재여부를 기억 못할것이다. 이 문제를 해결하기 위해서 **이름**이 존재하는 정적 팩토리 메소드를 사용하자.

<br>

* ##### 생성자와는 달리 호출할 때 마다 새로운 객체를 생성해줄 필요가 없다.
변경 불가능 클래스라면 이미 만들어 놓은 객체를 활용할 수도 있고 이 객체를 캐시해놓고 Prototype으로 재사용하여 같은 객체를 생성할때 퍼포먼스를 향상 시킬수 있다. 핵심은 결코 객체를 생성하지 않는것이다.
`ex)Boolean.valueOf(Boolean)`

정적 팩토리를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. 이러한 기능을 갖춘 클래스를 `(instance-controlled class)개체 통제 클래스`라고 부른다. 개체 통제 클래스를 작성하는 결정적인 이유는 객체의 생성 패턴을 Singleton pattern을 따르도록 할 수도 있다. 또한 `==` 비교연산자를 이용해서 객체를 비교연산 할 수 있다. Object 클래스의 equals()를 사용하여 비교하는것보다 퍼포먼스가 더 좋다.

<br>

* ##### 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
이 뜻은 반환되는 클래스의 타입을 더 유연하게 설계할 수 있다는 것이다.
굳이 구현 클래스를 공개하지 않아도 추상 클래스로 자식 클래스를 return 해올 수 있다. 
```java
Won won = Money.getWonInstance();
```
이렇게 되면 부모 클래스의 정적 팩토리 메소드에 접근 자식 클래스를 가져와 자식 클래스의 API와 소통이 가능해진다.

<br>

* ##### 형인자 자료형(parameterized type)객체를 만들때 편하다.
아래 HashMap을 생성하는 코드를 봐보자
```java
Map<String, List<String>> map = new HashMap<String, List<String>>();
```
(OpenJDK 11version 기준으로 Map의 형인자는 삭제해줘도 정상작동 한다, 하지만 지금은 작동되지 않는 JDK 1.6 version 아래라 가정하고 진행한다.)
이렇게 자료형 명세를 중복하면 코드가 길고 복잡해지고 한눈에 들어오긴 어렵다. 하지만 정적 팩토리 메소드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다. 이런 기법을 type interface라고 한다. 아래의 제네릭 정적 팩토리 메소드를 봐보자
```java
public static <K, V> HashMap<K, V> newInstance() {
    return new HashMap<K, V>
}
``` 
이렇게 제네릭 팩토리 메소드를 만든다면 다시 HashMap을 생성할때
```java
Map<String, List<String>> map = HashMap.newInstance();
```
이런식으로 HashMap을 생성하면 된다. 하지만 이게 불행히도 HashMap에서 정식으로 제공하는 정적 팩토리 메소드가 아니다. 그렇다면 우리는 어떻게 해야하는가, 그건 바로 굳이 제공되는 정적 팩토리 메소드만을 사용하는게 아닌, 우리가 utilities 클래스에 직접 정적 팩토리 메소드를 구현하면 된다.

<br>

#### 정적 팩토리 메소드의 단점
* ##### 정적 팩토리 메소드만 있는 클래스를 만들기에는 public, protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없는 점이다.
생성자가 필요없더라도 하위 클래스를 만들기 위해서는 생성자가 필요하다. 단 public과 protected 접근 제어자의 생성자에 한에서다.
public한 정적 팩토리 메소드에서 반환하는 public하지 않은 클래스들도 마찬가지이다. 한가지 예시를 들자면 JCF를 이용해 예를 들 수 있다. JCF의 기본 구현 클래스들의 하위 클래스는 더이상 만들 수 없다 이유는 마찬가지로 생성자의 부재이기 때문이다. 하지만 세간에서는 이게 더 좋은 설계라고 하기도 한다.
그 이유는 상속(inheritance)대신 구성(compostion)기법을 쓰도록 장려한다는 이유에서이다.

<br>

* ##### 정적 팩토리 메소드가 다른 정적 메소드와 확연히 구분되지 않는 다는 점이다.
생성자의 경우 다른 정적 메소드와 섞여 있어도 구분이 확실하다 클래스명이 생성자의 이름이 되기 때문이다. 하지만 정적 팩토리 메소드는 다르다 정적 팩토리 메소드는 객체를 생성하는 정적 메소드이기 때문에 정적 메소드의 외관을 띈 정적 팩토리 메소드는 정적 메소드 사이에서 한눈에 구별하기 어렵다.